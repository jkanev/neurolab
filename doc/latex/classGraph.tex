\section{Graph Class Reference}
\label{classGraph}\index{Graph@{Graph}}
Inheritance diagram for Graph::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classGraph}
\end{center}
\end{figure}


\subsection{Detailed Description}
The graph of a function. 

A graph is the set of points p, with p = f(a), a element A, where A is the domain of f. This class is a matrix (containing a numerical representation of the graph) with dimension n+1, where n is the number of inputs to f. It is organized so that file $<$$<$ graph appends gnuplot-plottable matrix notation to 'file'. If used as a matrix, you have (for a function with one parameter) graph[i] is the i'th data point, and graph[i][0] is the input a\_\-i, and graph[i][1] is the output f(a\_\-i). The main difference to the normal matrix class is that all mathematical operations (integrate, differentiate, multiply, etc.) only work on the output values (i.e. on graph[..][1]). \begin{Desc}
\item[{\bf Todo}]Only two-dimensional graphs are implemented yet. Change this. \end{Desc}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
virtual double {\bf getSum} ()
\begin{CompactList}\small\item\em Sum of elements. \item\end{CompactList}\item 
{\bf Graph} \& {\bf multiply} (double d)
\begin{CompactList}\small\item\em Multiply with a scalar. \item\end{CompactList}\item 
{\bf Graph} \& {\bf add} (double d)
\begin{CompactList}\small\item\em Add a scalar. \item\end{CompactList}\item 
{\bf Graph} \& {\bf exp} ()
\begin{CompactList}\small\item\em Exponential. \item\end{CompactList}\item 
{\bf Graph} \& {\bf sqrt} ()
\begin{CompactList}\small\item\em Sqare root for each element. \item\end{CompactList}\item 
{\bf Graph} \& {\bf integrate} ()
\begin{CompactList}\small\item\em Integrate. \item\end{CompactList}\item 
{\bf Graph} \& {\bf differentiate} ()
\begin{CompactList}\small\item\em Differentiate. \item\end{CompactList}\item 
{\bf Graph} \& {\bf inverse} ()
\begin{CompactList}\small\item\em Calculate the inverse. \item\end{CompactList}\item 
void {\bf sortX} (int start=0, int end=-1)
\begin{CompactList}\small\item\em Sort the points according to the x values. \item\end{CompactList}\end{CompactItemize}


\subsection{Member Function Documentation}
\index{Graph@{Graph}!getSum@{getSum}}
\index{getSum@{getSum}!Graph@{Graph}}
\subsubsection[getSum]{\setlength{\rightskip}{0pt plus 5cm}virtual double Graph::getSum ()\hspace{0.3cm}{\tt  [inline, virtual]}}\label{classGraph_ff25a2ec09f0a126f3c5a745aab3c05f}


Sum of elements. 

This returns a sum of all elements. 

Reimplemented from {\bf Matrix} \doxyref{}{p.}{classMatrix_ce7cb752186ce1e77c384c330b70da06}.\index{Graph@{Graph}!multiply@{multiply}}
\index{multiply@{multiply}!Graph@{Graph}}
\subsubsection[multiply]{\setlength{\rightskip}{0pt plus 5cm}{\bf Graph}\& Graph::multiply (double {\em d})\hspace{0.3cm}{\tt  [inline, virtual]}}\label{classGraph_5d43783cffc8b918bc369ef682f52ee3}


Multiply with a scalar. 

Multiplies the graph with a scalar. A reference to the graph itself is returned for convenience, so that you can write things like m.multipliy(3).add(4) 

Reimplemented from {\bf Matrix} \doxyref{}{p.}{classMatrix_7bd69f4b88ddc6dfd5baf8ff34e199ac}.\index{Graph@{Graph}!add@{add}}
\index{add@{add}!Graph@{Graph}}
\subsubsection[add]{\setlength{\rightskip}{0pt plus 5cm}{\bf Graph}\& Graph::add (double {\em d})\hspace{0.3cm}{\tt  [inline, virtual]}}\label{classGraph_0a425dc6c4bd5ca8285170eafdd6ac75}


Add a scalar. 

Adds a scalar to each element of the graph. A reference to the graph itself is returned for convenience, so that you can write things like m.add( a ).multiply( b ) 

Reimplemented from {\bf Matrix} \doxyref{}{p.}{classMatrix_706f980960a6568019dfc127d907769a}.\index{Graph@{Graph}!exp@{exp}}
\index{exp@{exp}!Graph@{Graph}}
\subsubsection[exp]{\setlength{\rightskip}{0pt plus 5cm}{\bf Graph}\& Graph::exp ()\hspace{0.3cm}{\tt  [inline, virtual]}}\label{classGraph_c6ea443dc99102ee72fd0ff267851600}


Exponential. 

Transforms each element into its exponential. A reference to the graph itself is returned for convenience, so that you can write things like m.exp().multipliy( a ).add( b ) 

Reimplemented from {\bf Matrix} \doxyref{}{p.}{classMatrix_5e6e75a6ae93018c6f00fae801e87470}.\index{Graph@{Graph}!sqrt@{sqrt}}
\index{sqrt@{sqrt}!Graph@{Graph}}
\subsubsection[sqrt]{\setlength{\rightskip}{0pt plus 5cm}{\bf Graph}\& Graph::sqrt ()\hspace{0.3cm}{\tt  [inline, virtual]}}\label{classGraph_1a696305ee5b94c04ad599af637bad5b}


Sqare root for each element. 

Transforms each element into its square root. A reference to the graph itself is returned for convenience, so that you can write things like m.sqrt().multipliy( a ).add( b ) 

Reimplemented from {\bf Matrix} \doxyref{}{p.}{classMatrix_0dcf9c12907a8ca31a4dac84c59d314c}.\index{Graph@{Graph}!integrate@{integrate}}
\index{integrate@{integrate}!Graph@{Graph}}
\subsubsection[integrate]{\setlength{\rightskip}{0pt plus 5cm}{\bf Graph}\& Graph::integrate ()\hspace{0.3cm}{\tt  [inline, virtual]}}\label{classGraph_2e7cbab8a86a9472647d28e6fa74d9bb}


Integrate. 

This function integrates over the last dimension of the graph. A cumulative sum is produced, where m'[0] = m[0], m'[1] = m[0]+m[1], m'[n] = m[0] + m[1] + ... + m[n]. Doing this on a differentiated graph, m.differentiate().\doxyref{integrate()}{p.}{classGraph_2e7cbab8a86a9472647d28e6fa74d9bb}, retrieves the original graph, shifted so that m[0] = 0.0, and adding the original m[0] restores the original graph. 

Reimplemented from {\bf Matrix} \doxyref{}{p.}{classMatrix_f2bd7e7a93e22420c8c16802681df0ab}.\index{Graph@{Graph}!differentiate@{differentiate}}
\index{differentiate@{differentiate}!Graph@{Graph}}
\subsubsection[differentiate]{\setlength{\rightskip}{0pt plus 5cm}{\bf Graph}\& Graph::differentiate ()\hspace{0.3cm}{\tt  [inline, virtual]}}\label{classGraph_3e5196c94e169602dc9846fa96ea7fef}


Differentiate. 

This function differentiates over the last dimension of the graph. A difference-graph is produced, where m'[0] = 0.0, m'[1] = m[1]-m[0], m'[n] = m[n]-m[n-1]. Doing this on an integrated graph, m.integrate().\doxyref{differentiate()}{p.}{classGraph_3e5196c94e169602dc9846fa96ea7fef}, restores the original graph, but m[0] will be lost (set to 0.0). 

Reimplemented from {\bf Matrix} \doxyref{}{p.}{classMatrix_25bd8d9f0a8e571e02612f2e199b3278}.\index{Graph@{Graph}!inverse@{inverse}}
\index{inverse@{inverse}!Graph@{Graph}}
\subsubsection[inverse]{\setlength{\rightskip}{0pt plus 5cm}{\bf Graph}\& Graph::inverse ()\hspace{0.3cm}{\tt  [inline]}}\label{classGraph_abab1421aba07044ece98faa3f5ac903}


Calculate the inverse. 

This function just swaps x and y of the graph, and calls \doxyref{sortX()}{p.}{classGraph_d103ae4b9938d4e0520d86c9b42cb615} so that all x values are in ascending order afterwards. \index{Graph@{Graph}!sortX@{sortX}}
\index{sortX@{sortX}!Graph@{Graph}}
\subsubsection[sortX]{\setlength{\rightskip}{0pt plus 5cm}void Graph::sortX (int {\em start} = {\tt 0}, \/  int {\em end} = {\tt -1})\hspace{0.3cm}{\tt  [inline]}}\label{classGraph_d103ae4b9938d4e0520d86c9b42cb615}


Sort the points according to the x values. 

This function is used by the \doxyref{inverse()}{p.}{classGraph_abab1421aba07044ece98faa3f5ac903} function, after swapping x and y. It sorts all points of the graph, so that the x values of all points will be in ascending order. The currently implemented method is merge sort. 