\section{Matrix Class Reference}
\label{classMatrix}\index{Matrix@{Matrix}}
Inheritance diagram for Matrix::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3cm]{classMatrix}
\end{center}
\end{figure}


\subsection{Detailed Description}
a matrix class 

Quick matrix class to implement matrices which know their own dimension. Supports any dimension, slicing, subindexing, as well as the matlab-known funktions cumsum, cummult and convolve (not implemented yet). Dimensions 0 up to 4 have shortcuts. The data inside the matrix are physical values and therefore have a unit (use \doxyref{Physical::getUnit()}{p.}{classPhysical_57174c2980a2e5ff5e4bf4f0c6450bd6} from the \doxyref{Physical}{p.}{classPhysical} class), and each dimension has a separate unit as well (use Matrix::getUnit(n)). Example: if you have voltage data, which you collected over time and length, you have a two-dimensional matrix; the matrix unit should be voltage, and one dimension should have cm, mm or whatever, and the other dimension ms, s etc. \begin{Desc}
\item[{\bf Todo}]Implement \doxyref{Matrix}{p.}{classMatrix} multiplication and the (Matlab-known) functions cumsum, cummult and convolve for n-dimensional matrixes. \end{Desc}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
{\bf Matrix} ()\label{classMatrix_2dba13c45127354c9f75ef576f49269b}

\begin{CompactList}\small\item\em default constructor: constructs a zero-dimensional matrix (a scalar). \item\end{CompactList}\item 
{\bf Matrix} (int i)\label{classMatrix_bd2c028d9a6eec0d4081964420d8b72a}

\begin{CompactList}\small\item\em constructs a one-dimensional matrix \item\end{CompactList}\item 
{\bf Matrix} (int i, int j)\label{classMatrix_f69aee84af5e2c1851eabd46ec65fc59}

\begin{CompactList}\small\item\em constructs a two-dimensional matrix \item\end{CompactList}\item 
{\bf Matrix} (int i, int j, int k)\label{classMatrix_82100b10bc59c0045d2723b5837fd886}

\begin{CompactList}\small\item\em constructs a three-dimensional matrix \item\end{CompactList}\item 
{\bf Matrix} (int i, int j, int k, int l)\label{classMatrix_89986abcf996c3ac829b8d4524477386}

\begin{CompactList}\small\item\em constructs a four-dimensional matrix \item\end{CompactList}\item 
{\bf Matrix} (int dimensions, int $\ast$sizes)\label{classMatrix_0a6ee725678483f5bcb0aa3f0fcf5845}

\begin{CompactList}\small\item\em constructs an n-dimensional matrix \item\end{CompactList}\item 
virtual {\bf $\sim$Matrix} ()\label{classMatrix_c8d10e89f7b47ab95a341d70df651554}

\begin{CompactList}\small\item\em destructs the matrix \item\end{CompactList}\item 
{\bf Matrix} \& {\bf setName} (const string \&)\label{classMatrix_efaec5c8693ce2ea84874c8e1513daff}

\begin{CompactList}\small\item\em set name \item\end{CompactList}\item 
string {\bf sName} ()\label{classMatrix_a7ff6121039385cf3d5f0dd5243b4198}

\begin{CompactList}\small\item\em get name \item\end{CompactList}\item 
int {\bf nDimension} ()\label{classMatrix_29dabe0cfbc4729505f4ac81f3703b18}

\begin{CompactList}\small\item\em Get number of dimensions. \item\end{CompactList}\item 
int {\bf nSize} (int n)\label{classMatrix_7869b36d4a5068a455e3c84697714cd1}

\begin{CompactList}\small\item\em Get size for dimension. \item\end{CompactList}\item 
{\bf Unit} {\bf getUnit} (int n)\label{classMatrix_127bdf325a41eb83d147febe99d56ed1}

\begin{CompactList}\small\item\em \doxyref{Unit}{p.}{classUnit} of dimension n. \item\end{CompactList}\item 
void {\bf setPhysical} (int n, {\bf Physical} p)
\begin{CompactList}\small\item\em Set physical dimension of dimension n. \item\end{CompactList}\item 
void {\bf setPhysical} ({\bf Physical} p)
\begin{CompactList}\small\item\em Set main physical dimension. \item\end{CompactList}\item 
{\bf Physical} {\bf pPhysical} (int n)
\begin{CompactList}\small\item\em Get physical dimension for dimension n. \item\end{CompactList}\item 
{\bf Matrix} {\bf operator[$\,$]} (int i)
\begin{CompactList}\small\item\em retrieve slices or values \item\end{CompactList}\item 
{\bf Matrix} \& {\bf remove} (vector$<$ int $>$)
\begin{CompactList}\small\item\em remove one or more dimensions \item\end{CompactList}\item 
void {\bf operator++} (int i)\label{classMatrix_d76bc9e63fa0ce0bcd7013fdd94b505e}

\begin{CompactList}\small\item\em increment a zero-dimensional matrix \item\end{CompactList}\item 
void {\bf operator=} (double d)
\begin{CompactList}\small\item\em assignment \item\end{CompactList}\item 
{\bf Matrix} \& {\bf operator+=} (const {\bf Matrix} \&)
\begin{CompactList}\small\item\em addings \item\end{CompactList}\item 
{\bf Matrix} {\bf operator()} (int i, int j)
\begin{CompactList}\small\item\em retrieve ranges - not implemented yet! \item\end{CompactList}\item 
double {\bf to\_\-d} ()
\begin{CompactList}\small\item\em convert to double \item\end{CompactList}\item 
virtual double {\bf getSum} ()
\begin{CompactList}\small\item\em Sum of elements. \item\end{CompactList}\item 
double {\bf getMaxValue} ()\label{classMatrix_e53619ed2877bf250f5e68b0722ae1ad}

\begin{CompactList}\small\item\em get maximal value \item\end{CompactList}\item 
double {\bf getMinValue} ()\label{classMatrix_5e8311eead808323e1ca79a41d2d0308}

\begin{CompactList}\small\item\em get minimal value \item\end{CompactList}\item 
void {\bf replaceNan} (double d)
\begin{CompactList}\small\item\em Replaces NaNs. \item\end{CompactList}\item 
virtual {\bf Matrix} \& {\bf multiply} (double d)
\begin{CompactList}\small\item\em Multiply with a scalar. \item\end{CompactList}\item 
virtual {\bf Matrix} \& {\bf add} (double d)
\begin{CompactList}\small\item\em Add a scalar. \item\end{CompactList}\item 
virtual {\bf Matrix} \& {\bf exp} ()
\begin{CompactList}\small\item\em Exponential. \item\end{CompactList}\item 
virtual {\bf Matrix} \& {\bf sqrt} ()
\begin{CompactList}\small\item\em Sqare root for each element. \item\end{CompactList}\item 
{\bf Matrix} \& {\bf transpose} ()
\begin{CompactList}\small\item\em Transpose matrix. \item\end{CompactList}\item 
virtual {\bf Matrix} \& {\bf integrate} ()
\begin{CompactList}\small\item\em Integrate. \item\end{CompactList}\item 
virtual {\bf Matrix} \& {\bf differentiate} ()
\begin{CompactList}\small\item\em Differentiate. \item\end{CompactList}\item 
{\bf Matrix} \& {\bf operator=} (const {\bf Matrix} \&m)\label{classMatrix_7f6e1b3cde4ab48a5c2269e27b05a222}

\begin{CompactList}\small\item\em assignment \item\end{CompactList}\item 
{\bf Matrix} (const {\bf Matrix} \&m)
\begin{CompactList}\small\item\em Copy constructor. \item\end{CompactList}\end{CompactItemize}
\subsection*{Friends}
\begin{CompactItemize}
\item 
ostream \& {\bf operator$<$$<$} (ostream \&s, const {\bf Matrix} \&m)\label{classMatrix_6f25321557e80072d03b83eee4f6df07}

\begin{CompactList}\small\item\em append matrix to a stream \item\end{CompactList}\item 
{\bf Matrix} {\bf operator-} (const {\bf Matrix} \&m0, const {\bf Matrix} \&m1)\label{classMatrix_cd30755098588cd9d521b40845de4fa6}

\begin{CompactList}\small\item\em subract two matrices \item\end{CompactList}\item 
{\bf Matrix} {\bf operator+} (const {\bf Matrix} \&m0, const {\bf Matrix} \&m1)\label{classMatrix_6564583226779e5f0458086b670940ce}

\begin{CompactList}\small\item\em add two matrices \item\end{CompactList}\end{CompactItemize}


\subsection{Constructor \& Destructor Documentation}
\index{Matrix@{Matrix}!Matrix@{Matrix}}
\index{Matrix@{Matrix}!Matrix@{Matrix}}
\subsubsection[Matrix]{\setlength{\rightskip}{0pt plus 5cm}Matrix::Matrix (const {\bf Matrix} \& {\em m})}\label{classMatrix_765f4dcb51b6829311cc3e7576388423}


Copy constructor. 

This creates a shallow copy, where the new \doxyref{Matrix}{p.}{classMatrix} takes over the memory, i.e. copy() is called with deep=false. 

\subsection{Member Function Documentation}
\index{Matrix@{Matrix}!setPhysical@{setPhysical}}
\index{setPhysical@{setPhysical}!Matrix@{Matrix}}
\subsubsection[setPhysical]{\setlength{\rightskip}{0pt plus 5cm}void Matrix::setPhysical (int {\em n}, \/  {\bf Physical} {\em p})}\label{classMatrix_f8966a39f15f6343a1d2064f769cfee3}


Set physical dimension of dimension n. 

Set a dimension n to a physical dimension, like f.i. 'acceleration'. If the matrix is plotted with a \doxyref{Display}{p.}{classDisplay} object, physical name and unit are shown on the appropriate axis. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]Dimension \item[{\em p}]\doxyref{Physical}{p.}{classPhysical} dimension \end{description}
\end{Desc}
\index{Matrix@{Matrix}!setPhysical@{setPhysical}}
\index{setPhysical@{setPhysical}!Matrix@{Matrix}}
\subsubsection[setPhysical]{\setlength{\rightskip}{0pt plus 5cm}void Matrix::setPhysical ({\bf Physical} {\em p})}\label{classMatrix_08cad528202811ab7d2f5eb210428878}


Set main physical dimension. 

Set the data inside the matrix to a physical dimension, like 'capacity'. If the matrix is plotted with a \doxyref{Display}{p.}{classDisplay} object, physical name and unit are shown on the appropriate axis. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em p}]\doxyref{Physical}{p.}{classPhysical} dimension \end{description}
\end{Desc}
\index{Matrix@{Matrix}!pPhysical@{pPhysical}}
\index{pPhysical@{pPhysical}!Matrix@{Matrix}}
\subsubsection[pPhysical]{\setlength{\rightskip}{0pt plus 5cm}{\bf Physical} Matrix::pPhysical (int {\em n})}\label{classMatrix_c994931577c0713a43adebd03c698649}


Get physical dimension for dimension n. 

Get the physical dimension of a dimension of the matrix. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em n}]The dimension \end{description}
\end{Desc}
\index{Matrix@{Matrix}!operator[]@{operator[]}}
\index{operator[]@{operator[]}!Matrix@{Matrix}}
\subsubsection[operator[]]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} Matrix::operator[$\,$] (int {\em i})}\label{classMatrix_1494942b9a98c6fe1d504959dca66e48}


retrieve slices or values 

(Note: these are references to the original matrix data.) \index{Matrix@{Matrix}!remove@{remove}}
\index{remove@{remove}!Matrix@{Matrix}}
\subsubsection[remove]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix}\& Matrix::remove (vector$<$ int $>$)}\label{classMatrix_2ca6c89fe110e107e61a0ae195409af4}


remove one or more dimensions 

input vector contains removal information: -1 means \char`\"{}do not remove\char`\"{}, positive integer n means \char`\"{}remove dimension n\char`\"{}. Example: if m is a (2,4,3) matrix, then m.remove([-1,-1,2]) will return a (2,4,2) matrix, where all m[x,x,2] data has been removed. \index{Matrix@{Matrix}!operator=@{operator=}}
\index{operator=@{operator=}!Matrix@{Matrix}}
\subsubsection[operator=]{\setlength{\rightskip}{0pt plus 5cm}void Matrix::operator= (double {\em d})}\label{classMatrix_e1d7db44b484c90357a79e84d774b055}


assignment 

This assigns the elements of the matrix. For assigning ranges use a for-loop. \index{Matrix@{Matrix}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!Matrix@{Matrix}}
\subsubsection[operator+=]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix}\& Matrix::operator+= (const {\bf Matrix} \&)}\label{classMatrix_5b683056bb65befdb3f06956abf4d428}


addings 

Adds another matrix. Shapes must be equal, otherwise nothing happens. \index{Matrix@{Matrix}!operator()@{operator()}}
\index{operator()@{operator()}!Matrix@{Matrix}}
\subsubsection[operator()]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix} Matrix::operator() (int {\em i}, \/  int {\em j})}\label{classMatrix_e6223b83489b662818f678dde5662bd3}


retrieve ranges - not implemented yet! 

(Note: these are references to the original matrix data.) Retrieves a matrix from i to j. Example: a = Matrix(6,6,6); (a will be a 6x6x6-Matrix). To get something like a[2..3][4..5][1..2] you write: a(2,3)(4,5)(1,2). \index{Matrix@{Matrix}!to\_\-d@{to\_\-d}}
\index{to\_\-d@{to\_\-d}!Matrix@{Matrix}}
\subsubsection[to\_\-d]{\setlength{\rightskip}{0pt plus 5cm}double Matrix::to\_\-d ()}\label{classMatrix_d2cd4921b39cec8cdc4cc1c652220f98}


convert to double 

This is mainly useful for zero-dimension matrixes. \index{Matrix@{Matrix}!getSum@{getSum}}
\index{getSum@{getSum}!Matrix@{Matrix}}
\subsubsection[getSum]{\setlength{\rightskip}{0pt plus 5cm}virtual double Matrix::getSum ()\hspace{0.3cm}{\tt  [virtual]}}\label{classMatrix_ce7cb752186ce1e77c384c330b70da06}


Sum of elements. 

This returns a sum of all elements. 

Reimplemented in {\bf Graph} \doxyref{}{p.}{classGraph_ff25a2ec09f0a126f3c5a745aab3c05f}.\index{Matrix@{Matrix}!replaceNan@{replaceNan}}
\index{replaceNan@{replaceNan}!Matrix@{Matrix}}
\subsubsection[replaceNan]{\setlength{\rightskip}{0pt plus 5cm}void Matrix::replaceNan (double {\em d})}\label{classMatrix_93d0989e22d2c6fe90a05d9e684d4bcd}


Replaces NaNs. 

Replace all NaN-valued members in the matrix with a given value. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em d}]Value which should replace any NaN-valued member. \end{description}
\end{Desc}
\index{Matrix@{Matrix}!multiply@{multiply}}
\index{multiply@{multiply}!Matrix@{Matrix}}
\subsubsection[multiply]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Matrix}\& Matrix::multiply (double {\em d})\hspace{0.3cm}{\tt  [virtual]}}\label{classMatrix_7bd69f4b88ddc6dfd5baf8ff34e199ac}


Multiply with a scalar. 

Multiplies the matrix with a scalar. A reference to the matrix itself is returned for convenience, so that you can write things like m.multipliy(3).add(4) 

Reimplemented in {\bf Graph} \doxyref{}{p.}{classGraph_5d43783cffc8b918bc369ef682f52ee3}.\index{Matrix@{Matrix}!add@{add}}
\index{add@{add}!Matrix@{Matrix}}
\subsubsection[add]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Matrix}\& Matrix::add (double {\em d})\hspace{0.3cm}{\tt  [virtual]}}\label{classMatrix_706f980960a6568019dfc127d907769a}


Add a scalar. 

Adds a scalar to each element of the matrix. A reference to the matrix itself is returned for convenience, so that you can write things like m.add( a ).multiply( b ) 

Reimplemented in {\bf Graph} \doxyref{}{p.}{classGraph_0a425dc6c4bd5ca8285170eafdd6ac75}.\index{Matrix@{Matrix}!exp@{exp}}
\index{exp@{exp}!Matrix@{Matrix}}
\subsubsection[exp]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Matrix}\& Matrix::exp ()\hspace{0.3cm}{\tt  [virtual]}}\label{classMatrix_5e6e75a6ae93018c6f00fae801e87470}


Exponential. 

Transforms each element into its exponential. A reference to the matrix itself is returned for convenience, so that you can write things like m.exp().multipliy( a ).add( b ) 

Reimplemented in {\bf Graph} \doxyref{}{p.}{classGraph_c6ea443dc99102ee72fd0ff267851600}.\index{Matrix@{Matrix}!sqrt@{sqrt}}
\index{sqrt@{sqrt}!Matrix@{Matrix}}
\subsubsection[sqrt]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Matrix}\& Matrix::sqrt ()\hspace{0.3cm}{\tt  [virtual]}}\label{classMatrix_0dcf9c12907a8ca31a4dac84c59d314c}


Sqare root for each element. 

Transforms each element into its square root. A reference to the matrix itself is returned for convenience, so that you can write things like m.sqrt().multipliy( a ).add( b ) 

Reimplemented in {\bf Graph} \doxyref{}{p.}{classGraph_1a696305ee5b94c04ad599af637bad5b}.\index{Matrix@{Matrix}!transpose@{transpose}}
\index{transpose@{transpose}!Matrix@{Matrix}}
\subsubsection[transpose]{\setlength{\rightskip}{0pt plus 5cm}{\bf Matrix}\& Matrix::transpose ()}\label{classMatrix_c1dbd7a135c98be8a91c2bff1f5a1365}


Transpose matrix. 

This changes the matrix data, so that m[x1][x2][x3]...[xn] becomes m[xn][xn-1][xn-2]...[x1]. A reference to the matrix itself is returned for convenience, so that you can write things like m.transpose().multipliy( a ).add( b ) \index{Matrix@{Matrix}!integrate@{integrate}}
\index{integrate@{integrate}!Matrix@{Matrix}}
\subsubsection[integrate]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Matrix}\& Matrix::integrate ()\hspace{0.3cm}{\tt  [virtual]}}\label{classMatrix_f2bd7e7a93e22420c8c16802681df0ab}


Integrate. 

This function integrates over the last dimension of the matrix. A cumulative sum is produced, where m'[0] = m[0], m'[1] = m[0]+m[1], m'[n] = m[0] + m[1] + ... + m[n]. Doing this on a differentiated matrix, m.differentiate().\doxyref{integrate()}{p.}{classMatrix_f2bd7e7a93e22420c8c16802681df0ab}, retrieves the original matrix, shifted so that m[0] = 0.0, and adding the original m[0] restores the original matrix. 

Reimplemented in {\bf Graph} \doxyref{}{p.}{classGraph_2e7cbab8a86a9472647d28e6fa74d9bb}.\index{Matrix@{Matrix}!differentiate@{differentiate}}
\index{differentiate@{differentiate}!Matrix@{Matrix}}
\subsubsection[differentiate]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Matrix}\& Matrix::differentiate ()\hspace{0.3cm}{\tt  [virtual]}}\label{classMatrix_25bd8d9f0a8e571e02612f2e199b3278}


Differentiate. 

This function differentiates over the last dimension of the matrix. A difference-matrix is produced, where m'[0] = 0.0, m'[1] = m[1]-m[0], m'[n] = m[n]-m[n-1]. Doing this on an integrated matrix, m.integrate().\doxyref{differentiate()}{p.}{classMatrix_25bd8d9f0a8e571e02612f2e199b3278}, restores the original matrix, but m[0] will be lost (set to 0.0). 

Reimplemented in {\bf Graph} \doxyref{}{p.}{classGraph_3e5196c94e169602dc9846fa96ea7fef}.